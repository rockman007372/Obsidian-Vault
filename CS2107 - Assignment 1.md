##### E1 
- The name of the challenge (Caesar Salad) gives away that I must use Caesar cipher, where each character in the message is replaced by a letter some fixed number of position away in the alphabet. This number is called the offset, and I have to find this offset.
- Since the flag is of format `CS2107{}`, this means `CS2107` corresponds to the `IY8763`. Hence, I can deduce the offset is 6 (meaning each letter in the plaintext is replaced by the 6th letter ahead from it in the alphabet).
- With this offset, I wrote a python script to reverse engineer the plaintext from the ciphertext, by replacing each letter in the cyphertext with the 6th letter behind it in the alphabet. 
##### E2
- After some Googling, I quickly found out about the Birds On The Wire Cipher. 
- I used an online [decoder](https://www.dcode.fr/birds-on-a-wire-cipher) to get the message.
##### E3
- I know XOR has a specific property: `if A XOR B = C, then A XOR C = B`
- Hence, given all the keys and the ciphertext, I can obtain the plaintext again by XOR-ing the ciphertext with all the keys
	- Since `plaintext XOR key = ciphertext`, `ciphertext xor key = plaintext`
- I wrote a python script to solve this.
##### M1

Method:
- I built a dictionary to map each 16-byte block in the output.txt file to its corresponding character in the chain.py file.
	- This is possible because ECB mode is deterministic, meaning the same input will always produce the same output. Hence, I was able to do a 1-1 mapping between each character and its encoded 16-byte block.
	- I truncated the original chain.py until the line right before the flag. This is because we only have information about the 1-to-1 mapping between the character and its corresponding encoded block until this point.
- Using this dictionary, I was able to reverse engineer the encoded output back its original python code.


![[Pasted image 20241005191737.png]]

Challenges:
- This challenge took me more time than expected due to a bug caused by the difference in new line formats in Window (`\n\r`) and Linux (`\n`). This disparity caused the dictionary to be off-by-one whenever a new line character was encountered. Running the code in WSL fixed this problem.

#### M2

- To decrypt the ciphertext, I need the private key in the classroom RSA algorithm, which is `<n, d>`. Since `n` is provided, i need to find `d`, which is the descyption exponent, where  $$de \mod (p - 1) (q - 1) = 1$$
- Thus, `d` is calculated using the formula: $$d = e^{-1} \mod (p-1)(q-1)$$
- From `d`, the plaintext `m` is obtained using the formula: $$m = c^{d} \mod n$$
- All these calculations are done inside the python script.
#### H2

- To solve this problem, I went to read the documentation for python `random` module. Specifically, I was wondering what Python would choose as the seed if it was not given any. This is because I wrongly assumed that the server generator has no seed number.
- Since the documentation said that `random` module chooses the current system time `time.time()` as the seed if it is not provided, I tried to capture the time on my machine the moment I communicated with the remote server, and used it as seed for my own random object. 
	- Obviously, this approach does not work. There is no way to capture the time the server received the message. Furthermore, the server most likely had a seed for its `random` object too, so my assumption was probably wrong from the start.
- After I gave up on this approach, I went to Google for inspiration, and found this Stack Overflow [post](https://stackoverflow.com/questions/77076663/rng-challenge-python). The post basically provided the solution to this problem, which is the `rancrack` tool.
	- After the `rancrack` cracker is fed the first 624 32-bit numbers from the random number generator, the cracker can guess all the numbers generated onwards without knowing the seed.
	- I simply had to provide the wrong answer to the server to obtain the first 624 numbers generated by the server to feed to the cracker. On the 625 attempt, the cracker already had enough information to guess the next number.

![[Pasted image 20241006175750.png]]

